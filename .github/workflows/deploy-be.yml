name: Deploy Backend

on:
  push:
    branches: [develop, main]
    paths:
      - 'MinMinBE/**'
      - 'MinMinBE/.env'
      - 'docker-compose.yml'
      - 'Dockerrun.aws.json'
      - '.github/workflows/deploy-be.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_BACKEND: ${{ secrets.ECR_BACKEND }}
  EB_APP: ${{ secrets.EB_APP }}
  EB_ENV: ${{ secrets.EB_ENV }}
  EB_S3_BUCKET: ${{ secrets.EB_S3_BUCKET }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure tooling (jq, zip)
        shell: bash
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq zip

      - name: Login to ECR
        shell: bash
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "$ECR_BACKEND"

      - name: Build and push image
        shell: bash
        run: |
          set -euo pipefail
          GITSHA=$(git rev-parse --short HEAD)
          docker build -t "$ECR_BACKEND:$GITSHA" MinMinBE
          docker push "$ECR_BACKEND:$GITSHA"
          echo "GITSHA=$GITSHA" >> "$GITHUB_ENV"

      - name: Generate EB option settings from .env
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PYTHON'
          import json, pathlib
          env_file = pathlib.Path('MinMinBE/.env')
          options = []
          if env_file.exists():
              for raw in env_file.read_text().splitlines():
                  line = raw.strip()
                  if not line or line.startswith('#') or '=' not in line:
                      continue
                  key, value = line.split('=', 1)
                  options.append({
                      "Namespace": "aws:elasticbeanstalk:application:environment",
                      "OptionName": key.strip(),
                      "Value": value.strip()
                  })
          with open('options.json', 'w') as f:
              json.dump(options, f)
          PYTHON
          echo "Generated options.json"

      - name: Prepare Dockerrun with current image
        shell: bash
        run: |
          set -euo pipefail
          jq --arg IMAGE "$ECR_BACKEND:$GITSHA" \
             '.containerDefinitions[0].image = $IMAGE' \
             Dockerrun.aws.json > Dockerrun.generated.json
          echo "Prepared Dockerrun.generated.json"

      - name: Package and upload bundle to S3
        shell: bash
        run: |
          set -euo pipefail
          zip -r app.zip Dockerrun.generated.json >/dev/null
          aws s3 cp app.zip "s3://$EB_S3_BUCKET/$GITSHA.zip"

      - name: Create (or confirm) EB application version
        shell: bash
        run: |
          set -euo pipefail
          if aws elasticbeanstalk describe-application-versions \
              --application-name "$EB_APP" \
              --query "ApplicationVersions[?VersionLabel=='$GITSHA'] | length(@)" \
              --output text | grep -q '^1$'; then
            echo "Application version $GITSHA already exists."
          else
            aws elasticbeanstalk create-application-version \
              --application-name "$EB_APP" \
              --version-label "$GITSHA" \
              --source-bundle S3Bucket="$EB_S3_BUCKET",S3Key="$GITSHA.zip" \
              --auto-create-application
          fi

      - name: Deploy (recreate if stack is missing; auto-pick platform)
        shell: bash
        run: |
          set -euo pipefail

          # 1) Discover current EB env (may be orphaned)
          ENV_DESC_JSON=$(aws elasticbeanstalk describe-environments \
            --application-name "$EB_APP" \
            --environment-names "$EB_ENV" \
            --query 'Environments[0]' --output json 2>/dev/null || echo 'null')

          STATUS=$(jq -r '.Status // "None"' <<<"$ENV_DESC_JSON")
          ENV_ID=$(jq -r '.EnvironmentId // "None"' <<<"$ENV_DESC_JSON")
          EXISTING_PLATFORM_ARN=$(jq -r '.PlatformArn // empty' <<<"$ENV_DESC_JSON")

          echo "STATUS=$STATUS ENV_ID=$ENV_ID EXISTING_PLATFORM_ARN=${EXISTING_PLATFORM_ARN:-<none>}"

          # 2) Read CFN stack; if missing, we must recreate
          STACK_NAME=""
          if [ "$STATUS" != "None" ] && [ "$STATUS" != "Terminated" ]; then
            STACK_NAME=$(aws elasticbeanstalk describe-environment-resources \
              --environment-name "$EB_ENV" \
              --query 'EnvironmentResources.StackName' --output text 2>/dev/null || echo "")
          fi
          echo "STACK_NAME=${STACK_NAME:-<none>}"

          STACK_OK="no"
          if [ -n "${STACK_NAME}" ] && [ "${STACK_NAME}" != "None" ]; then
            if aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
              STACK_OK="yes"
            fi
          fi
          echo "STACK_OK=$STACK_OK"

          # 3) Decide platform ARN based on Dockerrun format or reuse existing
          detect_platform_arn() {
            if [ -n "${EXISTING_PLATFORM_ARN:-}" ]; then
              echo "$EXISTING_PLATFORM_ARN"
              return 0
            fi
            if jq -e '.containerDefinitions' Dockerrun.generated.json >/dev/null 2>&1; then
              echo "Detected Dockerrun v2 (multicontainer). Selecting AL2 ECS platform." >&2
              aws elasticbeanstalk list-platform-versions \
                --filters Type=PlatformName,Operator==,Values='Multi-container Docker running on 64bit Amazon Linux 2' \
                --query 'PlatformSummaryList[0].PlatformArn' --output text
              return 0
            fi
            echo "Detected single-container. Selecting AL2023 Docker platform." >&2
            aws elasticbeanstalk list-platform-versions \
              --filters Type=PlatformName,Operator==,Values='Docker running on 64bit Amazon Linux 2023' \
              --query 'PlatformSummaryList[0].PlatformArn' --output text
          }

          PLATFORM_ARN=$(detect_platform_arn)
          if [ -z "$PLATFORM_ARN" ] || [ "$PLATFORM_ARN" = "None" ]; then
            echo "ERROR: Could not resolve a platform ARN. Aborting." >&2
            exit 1
          fi
          echo "PLATFORM_ARN=$PLATFORM_ARN"

          recreate_env() {
            echo "Recreating environment $EB_ENV..."
            if [ "$STATUS" != "None" ] && [ "$STATUS" != "Terminated" ]; then
              aws elasticbeanstalk terminate-environment --environment-name "$EB_ENV" --force || true
              echo "Waiting for termination..."
              aws elasticbeanstalk wait environment-terminated --environment-name "$EB_ENV" || true
            fi
            aws elasticbeanstalk create-environment \
              --application-name "$EB_APP" \
              --environment-name "$EB_ENV" \
              --version-label "$GITSHA" \
              --platform-arn "$PLATFORM_ARN" \
              --option-settings file://options.json
          }

          if [ "$STATUS" = "None" ] || [ "$STATUS" = "Terminated" ]; then
            echo "Environment missing/terminated -> create"
            recreate_env
          else
            if [ "$STACK_OK" = "yes" ]; then
              echo "Stack healthy -> update existing environment"
              aws elasticbeanstalk update-environment \
                --application-name "$EB_APP" \
                --environment-name "$EB_ENV" \
                --version-label "$GITSHA" \
                --option-settings file://options.json
            else
              echo "Environment record exists but stack is missing -> recreate"
              recreate_env
            fi
          fi

      - name: Wait for deployment and print URL
        shell: bash
        run: |
          set -euo pipefail
          aws elasticbeanstalk wait environment-updated --environment-name "$EB_ENV"
          aws elasticbeanstalk wait environment-green --environment-name "$EB_ENV" || true
          URL=$(aws elasticbeanstalk describe-environments \
            --application-name "$EB_APP" \
            --environment-names "$EB_ENV" \
            --query "Environments[0].CNAME" --output text)
          echo "Environment URL: http://$URL"
