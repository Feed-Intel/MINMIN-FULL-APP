name: Deploy to Single EC2 (Docker Compose)

on:
  push:
    branches: ['main']
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  actions: write

env:
  API_IMAGE_NAME: minmin-api
  CUSTOMER_IMAGE_NAME: customer-frontend

jobs:
  build_images:
    name: Build and Push API Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase owner
        id: owner
        run: echo "lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=sha,format=long
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ./MinMinBE
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Extract metadata (tags, labels) for frontend
        id: meta-fe
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.owner.outputs.lc }}/${{env.CUSTOMER_IMAGE_NAME}}
          tags: |
            type=sha,format=long
            type=raw,value=latest

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: ./customerFE
          push: true
          tags: ${{ steps.meta-fe.outputs.tags }}
          labels: ${{ steps.meta-fe.outputs.labels }}
          build-args: |
            EXPO_PUBLIC_API_URL=https://${{ vars.API_DOMAIN }}/api/v1
            EXPO_PUBLIC_BACKEND_URL=https://${{ vars.API_DOMAIN }}/api
            EXPO_PUBLIC_API_KEY=${{ secrets.API_KEY || '' }}
            EXPO_PUBLIC_DOMAIN=.feed-intel.com
            EXPO_PUBLIC_WS_URL=wss://${{ vars.API_DOMAIN }}/ws/user
            EXPO_PUBLIC_BASE_URL=${{ vars.EXPO_PUBLIC_BASE_URL }}
            EXPO_PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID || '' }}
            GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET || '' }}
            FACEBOOK_CLIENT_ID=${{ secrets.FACEBOOK_CLIENT_ID || '' }}
            FACEBOOK_CLIENT_SECRET=${{ secrets.FACEBOOK_CLIENT_SECRET || '' }}
            EXPO_PUBLIC_CHAPA_CHECKOUT_URL=${{ vars.CHAPA_CHECKOUT_URL || '' }}
            EXPO_PUBLIC_TELEBIRR_API=${{ vars.TELEBIRR_API || '' }}
            EXPO_PUBLIC_TELEBIRR_APPSECRET=${{ secrets.TELEBIRR_APPSECRET || '' }}
            EXPO_PUBLIC_FABRIC_ID=${{ secrets.FABRIC_ID || '' }}
            EXPO_PUBLIC_PRIVATEKEY=${{ secrets.PRIVATEKEY || '' }}
            EXPO_PUBLIC_MERCHANT_APPID=${{ secrets.MERCHANT_APPID || '' }}
            EXPO_PUBLIC_MERCHANT_SHORTCODE=${{ secrets.MERCHANT_SHORTCODE || '' }}
            EXPO_PUBLIC_SCHEME=minmin://

  build_restaurant:
    name: Build Frontend (Restaurant web)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install and build restaurantFE
        working-directory: restaurantFE
        env:
          EXPO_PUBLIC_API_URL: https://${{ vars.API_DOMAIN }}/api/v1
          EXPO_PUBLIC_BACKEND_URL: https://${{ vars.API_DOMAIN }}/api/
          EXPO_PUBLIC_IMAGE_PATH: https://${{ vars.API_DOMAIN }}
          EXPO_PUBLIC_WS_URL: wss://${{ vars.API_DOMAIN }}/ws/restaurant/
          EXPO_PUBLIC_API_KEY: ${{ secrets.API_KEY }}
        run: |
          npm ci
          npx --yes expo export --platform web --non-interactive

      - name: Delete old restaurant artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          artifacts=$(gh api repos/${{ github.repository }}/actions/artifacts \
            --paginate -q '.artifacts[] | select(.name=="restaurant-web-dist") | .id')

          for artifact_id in $artifacts; do
            echo "Deleting artifact ID: $artifact_id"
            gh api --method DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id
          done

      - name: Upload restaurantFE artifact
        uses: actions/upload-artifact@v4
        with:
          name: restaurant-web-dist
          path: restaurantFE/dist

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [build_images, build_restaurant]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase owner
        id: owner
        run: echo "lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Validate GHCR credentials and access
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          IMAGE: ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}:latest
        run: |
          set -euo pipefail
          if [ -z "${GHCR_USERNAME:-}" ] || [ -z "${GHCR_TOKEN:-}" ]; then
            echo "::error::GHCR_USERNAME or GHCR_TOKEN is not set in repo secrets" >&2
            exit 1
          fi
          echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
          # Try to pull the image built in the previous job; warn if first run
          if ! docker pull "$IMAGE" >/dev/null 2>&1; then
            echo "::warning::Could not pull $IMAGE. If this is the first deploy, this is expected. Credentials validated."
          else
            echo "Verified pull access to $IMAGE"
          fi
          docker logout ghcr.io

      - name: Verify required files exist in workspace
        run: |
          set -e
          ls -la
          ls -la deploy
          ls -la deploy/nginx
          ls -la deploy/nginx/conf.d

      - name: Create target directories on server
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            sudo mkdir -p \
              /opt/minmin/deploy \
              /opt/minmin/deploy/nginx \
              /opt/minmin/deploy/nginx/conf.d \
              /opt/minmin/nginx/conf.d \
              /opt/minmin/tls \
              /opt/minmin/tls/stg.api.feed-intel.com \
              /opt/minmin/tls/stg.customer.feed-intel.com \
              /opt/minmin/tls/stg.restaurant.feed-intel.com \
              /opt/minmin/acme \
              /opt/minmin/letsencrypt
            sudo chown -R $USER:$USER /opt/minmin

      - name: Ensure TLS certs exist (self-signed fallback for staging)
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            gen_cert() {
              domain="$1"
              dir="/opt/minmin/tls/$domain"
              crt="$dir/fullchain.pem"
              key="$dir/privkey.pem"
              mkdir -p "$dir"
              if [ -s "$crt" ] && [ -s "$key" ]; then
                echo "$domain: TLS certs already present"
                return 0
              fi
              echo "Generating self-signed certs for $domain (staging fallback)"
              openssl req -x509 -nodes -newkey rsa:2048 \
                -subj "/CN=$domain" \
                -days 365 \
                -keyout "$key" -out "$crt" >/dev/null 2>&1 || true
              chmod 600 "$key"
            }
            gen_cert stg.api.feed-intel.com
            gen_cert stg.customer.feed-intel.com
            gen_cert stg.restaurant.feed-intel.com

      - name: Download restaurantFE artifact
        uses: actions/download-artifact@v4
        with:
          name: restaurant-web-dist
          path: dist

      - name: Upload deployment bundle
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: deploy/**
          target: /opt/minmin/
          overwrite: true
          debug: true
          strip_components: 1

      - name: Verify compose and nginx on server
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Listing /opt/minmin:"
            ls -la /opt/minmin
            echo "Listing /opt/minmin/nginx:"
            ls -la /opt/minmin/nginx
            echo "Listing /opt/minmin/nginx/conf.d:"
            ls -la /opt/minmin/nginx/conf.d

      - name: Verify nginx files on server
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Listing /opt/minmin/nginx and conf.d on server:"
            ls -la /opt/minmin/nginx || true
            ls -la /opt/minmin/nginx/conf.d || true

      - name: Start nginx and smoke test
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            # Ensure compose file exists
            test -f /opt/minmin/docker-compose.prod.yml || (echo "::error::Missing compose file at /opt/minmin/docker-compose.prod.yml" && exit 1)
            # Bring up supporting services for smoke tests
            echo "API_IMAGE=ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}:latest" | sudo tee /opt/minmin/deploy.env >/dev/null
            echo "CUSTOMER_IMAGE=ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.CUSTOMER_IMAGE_NAME }}:latest" | sudo tee -a /opt/minmin/deploy.env >/dev/null
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml down
            images=$(sudo docker images -q)
            if [ -n "$images" ]; then
              sudo docker rmi -f $images
            else
              echo "No images to remove"
            fi
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d nginx
            # Wait for Nginx to accept connections on :80
            for i in $(seq 1 20); do
              if curl -sI http://localhost >/dev/null; then
                echo "Nginx reachable on :80"
                break
              fi
              echo "Attempt $i: Nginx not yet reachable; sleeping 2s"
              sleep 2
              if [ "$i" = "20" ]; then
                echo '::error::Nginx not reachable on localhost after retries'
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml ps
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml logs nginx || true
                exit 1
              fi
            done

      - name: Issue Let's Encrypt certificates (webroot)
        if: ${{ vars.CERTBOT_EMAIL != '' }}
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            EMAIL='${{ vars.CERTBOT_EMAIL }}'
            if [ -z "$EMAIL" ]; then
              echo '::warning::CERTBOT_EMAIL repo variable is empty; skipping LE issuance'
              exit 0
            fi
            # Request/renew certs via webroot (served by nginx)
            sudo docker run --rm \
              -v /opt/minmin/tls:/etc/letsencrypt \
              -v /opt/minmin/acme:/var/www/certbot \
              certbot/certbot:latest certonly --webroot -w /var/www/certbot \
              -d stg.api.feed-intel.com -d stg.customer.feed-intel.com -d stg.restaurant.feed-intel.com \
              --agree-tos -m "$EMAIL" --no-eff-email --non-interactive --keep-until-expiring || true

            sync_copy() {
              dom="$1"; src="/opt/minmin/letsencrypt/live/$dom"; dst="/opt/minmin/tls/$dom";
              if [ -d "$src" ]; then
                sudo install -m 0644 -D "$src/fullchain.pem" "$dst/fullchain.pem"
                sudo install -m 0600 -D "$src/privkey.pem" "$dst/privkey.pem"
                echo "Installed certs for $dom"
              else
                echo "::warning::No LE cert directory for $dom; using existing certs if any"
              fi
            }
            sync_copy stg.api.feed-intel.com
            sync_copy stg.customer.feed-intel.com
            sync_copy stg.restaurant.feed-intel.com

            # Reload nginx to pick up new certs (ignore failures)
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml exec -T nginx nginx -s reload || true

      - name: Remove old restaurant folder if exists
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            if [ -d "/opt/minmin/restaurant" ]; then
              echo "Removing old /opt/minmin/restaurant"
              sudo rm -rf /opt/minmin/restaurant
            else
              echo "No existing /opt/minmin/restaurant found, skipping"
            fi
            sudo mkdir -p /opt/minmin/restaurant
            sudo chown -R $USER:$USER /opt/minmin/restaurant

      - name: Copy static sites to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: |
            dist/*
          target: /opt/minmin/restaurant

      - name: Verify and normalize static site roots
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Restaurant root contents:"; ls -la /opt/minmin/restaurant || true
            # Ensure safe read perms for nginx
            sudo find /opt/minmin/restaurant -type d -exec chmod 755 {} +
            sudo find /opt/minmin/restaurant -type f -exec chmod 644 {} +
            sudo mv /opt/minmin/restaurant/dist/** /opt/minmin/restaurant
            echo "Restaurant (unchanged root):"; ls -la /opt/minmin/restaurant | head -n 40 || true
            echo "Post-normalize Customer:"; ls -la /opt/minmin/customer | head -n 40; ls -la /opt/minmin/customer/client | head -n 40 || true
            # Reload nginx to ensure it serves updated static
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml exec -T nginx nginx -s reload || \
              sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml restart nginx

      - name: Remote setup & deploy
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            sudo mkdir -p /opt/minmin/{restaurant,media}
            sudo chown -R $USER:$USER /opt/minmin

            # Install Docker if missing
            if ! command -v docker >/dev/null 2>&1; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
            fi
            if ! docker compose version >/dev/null 2>&1; then
              echo "Installing docker compose plugin..."
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi

            # Login to GHCR for private image pulls
            echo ${{ secrets.GHCR_TOKEN }} | sudo docker login ghcr.io -u ${{ secrets.GHCR_USERNAME }} --password-stdin

            # Compose deploy env (for variable substitution like API_IMAGE)
            echo "API_IMAGE=ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}:latest" | sudo tee /opt/minmin/deploy.env >/dev/null
            echo "CUSTOMER_IMAGE=ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.CUSTOMER_IMAGE_NAME }}:latest" | sudo tee -a /opt/minmin/deploy.env >/dev/null

            # API application env
            sudo bash -c "echo 'DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}' > /opt/minmin/api.env"
            sudo bash -c "echo 'DJANGO_SETTINGS_MODULE=minminbe.settings' >> /opt/minmin/api.env"
            sudo bash -c "echo 'DEBUG=false' >> /opt/minmin/api.env"
            sudo bash -c "echo 'ALLOWED_HOSTS=${{ vars.API_DOMAIN }},${{ vars.CUSTOMER_DOMAIN }},${{ vars.RESTAURANT_DOMAIN }},localhost,127.0.0.1,stg.customer.feed-intel.com,stg.restaurant.feed-intel.com,stg.api.feed-intel.com' >> /opt/minmin/api.env"
            sudo bash -c "echo 'CSRF_TRUSTED_ORIGINS=https://${{ vars.API_DOMAIN }},https://${{ vars.CUSTOMER_DOMAIN }},https://${{ vars.RESTAURANT_DOMAIN }},https://stg.restaurant.feed-intel.com,https://stg.customer.feed-intel.com' >> /opt/minmin/api.env"
            sudo bash -c "echo 'DJANGO_ALLOWED_CORS_ORIGINS=https://${{ vars.CUSTOMER_DOMAIN }},https://${{ vars.RESTAURANT_DOMAIN }},https://stg.restaurant.feed-intel.com,https://stg.customer.feed-intel.com' >> /opt/minmin/api.env"
            sudo bash -c "echo 'DATABASE_URL=${{ secrets.DATABASE_URL }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'REDIS_URL=${{ secrets.REDIS_URL }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'EMAIL_HOST=${{ vars.EMAIL_HOST || 'smtp.gmail.com' }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'EMAIL_HOST_USER=${{ secrets.EMAIL_HOST_USER || '' }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'EMAIL_HOST_PASSWORD=${{ secrets.EMAIL_HOST_PASSWORD || '' }}' >> /opt/minmin/api.env"

            # Inject domain names into nginx vhosts
            if [ -f /opt/minmin/nginx/conf.d/api.conf ]; then
              sed -i "s/api.local/${{ vars.API_DOMAIN }}/g" /opt/minmin/nginx/conf.d/api.conf
            else
              echo "::error::Missing /opt/minmin/nginx/conf.d/api.conf on server"; ls -la /opt/minmin/nginx/conf.d || true; exit 1
            fi
            if [ -f /opt/minmin/nginx/conf.d/customer.conf ]; then
              sed -i "s/customer.local/${{ vars.CUSTOMER_DOMAIN }}/g" /opt/minmin/nginx/conf.d/customer.conf
            else
              echo "::error::Missing /opt/minmin/nginx/conf.d/customer.conf on server"; exit 1
            fi
            if [ -f /opt/minmin/nginx/conf.d/restaurant.conf ]; then
              sed -i "s/restaurant.local/${{ vars.RESTAURANT_DOMAIN }}/g" /opt/minmin/nginx/conf.d/restaurant.conf
            else
              echo "::error::Missing /opt/minmin/nginx/conf.d/restaurant.conf on server"; exit 1
            fi

            # Reload nginx to pick up updated vhosts
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml restart nginx || \
              sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d nginx
            sleep 2

            # Sanity check compose file present
            test -f /opt/minmin/docker-compose.prod.yml || (echo "::error::Missing compose file at /opt/minmin/docker-compose.prod.yml" && exit 1)

            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml pull  --ignore-pull-failures|| true
            # Remove any orphaned/renamed services (like historical customer_server/customer_expo)
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d --remove-orphans

            # Health check with retries (API behind Nginx)
            echo "Waiting for API to become healthy..."
            for i in $(seq 1 20); do
              if curl -fsS -H "Host: ${{ vars.API_DOMAIN }}" -o /dev/null http://localhost/healthz/; then
                echo "API healthy on attempt $i"
                break
              fi
              echo "Attempt $i: API not ready yet; sleeping 3s"
              sleep 3
              if [ "$i" = "20" ]; then
                echo 'API health check failed after retries'
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml ps
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml logs api || true
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml logs nginx || true
                exit 1
              fi
            done

      - name: Finalize stack and verify healthz
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            # Ensure compose file exists
            test -f /opt/minmin/docker-compose.prod.yml
            # Make sure all services are up
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d
            # Health check with retries (header only)
            for i in $(seq 1 10); do
              status=$(curl -s -H "Host: ${{ vars.API_DOMAIN }}" -o /dev/null -w "%{http_code}" http://localhost/healthz/ || true)
              echo "healthz status: $status (attempt $i)"
              if [ "$status" = "200" ]; then
                echo "Final health check OK"
                break
              fi
              sleep 3
              if [ "$i" = "10" ]; then
                echo '::error::/healthz did not return 200 after retries'
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml ps
                exit 1
              fi
            done
