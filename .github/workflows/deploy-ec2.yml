name: Deploy to Single EC2 (Docker Compose)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  API_IMAGE_NAME: minmin-api

jobs:
  build_api:
    name: Build and Push API Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase owner
        id: owner
        run: echo "lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}
          tags: |
            type=sha,format=long
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ./MinMinBE
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  build_frontends:
    name: Build Frontends (static web)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install and build restaurantFE
        working-directory: restaurantFE
        env:
          EXPO_PUBLIC_API_URL: https://${{ vars.API_DOMAIN }}/api/v1
          EXPO_PUBLIC_BACKEND_URL: https://${{ vars.API_DOMAIN }}/api/
          EXPO_PUBLIC_IMAGE_PATH: https://${{ vars.API_DOMAIN }}
          EXPO_PUBLIC_WS_URL: wss://${{ vars.API_DOMAIN }}/ws/restaurant/
        run: |
          npm ci
          npx --yes expo export --platform web --non-interactive

      - name: Install and build customerFE
        working-directory: customerFE
        env:
          EXPO_PUBLIC_API_URL: https://${{ vars.API_DOMAIN }}/api/v1
          EXPO_PUBLIC_BACKEND_URL: https://${{ vars.API_DOMAIN }}/api
          EXPO_PUBLIC_BASE_URL: https://${{ vars.CUSTOMER_DOMAIN }}
          EXPO_PUBLIC_WS_URL: wss://${{ vars.API_DOMAIN }}/ws/user
        run: |
          npm ci
          npx --yes expo export --platform web --non-interactive

      - name: Upload restaurantFE artifact
        uses: actions/upload-artifact@v4
        with:
          name: restaurant-web-dist
          path: restaurantFE/dist

      - name: Upload customerFE artifact
        uses: actions/upload-artifact@v4
        with:
          name: customer-web-dist
          path: customerFE/dist

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [build_api, build_frontends]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase owner
        id: owner
        run: echo "lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Validate GHCR credentials and access
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          IMAGE: ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}:latest
        run: |
          set -euo pipefail
          if [ -z "${GHCR_USERNAME:-}" ] || [ -z "${GHCR_TOKEN:-}" ]; then
            echo "::error::GHCR_USERNAME or GHCR_TOKEN is not set in repo secrets" >&2
            exit 1
          fi
          echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
          # Try to pull the image built in the previous job; warn if first run
          if ! docker pull "$IMAGE" >/dev/null 2>&1; then
            echo "::warning::Could not pull $IMAGE. If this is the first deploy, this is expected. Credentials validated."
          else
            echo "Verified pull access to $IMAGE"
          fi
          docker logout ghcr.io

      - name: Verify required files exist in workspace
        run: |
          set -e
          ls -la
          ls -la deploy
          ls -la deploy/nginx
          ls -la deploy/nginx/conf.d

      - name: Create target directories on server
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            sudo mkdir -p \
              /opt/minmin/deploy \
              /opt/minmin/deploy/nginx \
              /opt/minmin/deploy/nginx/conf.d \
              /opt/minmin/nginx/conf.d \
              /opt/minmin/tls \
              /opt/minmin/tls/stg.api.feed-intel.com \
              /opt/minmin/tls/stg.customer.feed-intel.com \
              /opt/minmin/tls/stg.restaurant.feed-intel.com \
              /opt/minmin/acme \
              /opt/minmin/letsencrypt
            sudo chown -R $USER:$USER /opt/minmin

      - name: Ensure TLS certs exist (self-signed fallback for staging)
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            gen_cert() {
              domain="$1"
              dir="/opt/minmin/tls/$domain"
              crt="$dir/fullchain.pem"
              key="$dir/privkey.pem"
              mkdir -p "$dir"
              if [ -s "$crt" ] && [ -s "$key" ]; then
                echo "$domain: TLS certs already present"
                return 0
              fi
              echo "Generating self-signed certs for $domain (staging fallback)"
              openssl req -x509 -nodes -newkey rsa:2048 \
                -subj "/CN=$domain" \
                -days 365 \
                -keyout "$key" -out "$crt" >/dev/null 2>&1 || true
              chmod 600 "$key"
            }
            gen_cert stg.api.feed-intel.com
            gen_cert stg.customer.feed-intel.com
            gen_cert stg.restaurant.feed-intel.com

      - name: Download restaurantFE artifact
        uses: actions/download-artifact@v4
        with:
          name: restaurant-web-dist
          path: dist/restaurant

      - name: Download customerFE artifact
        uses: actions/download-artifact@v4
        with:
          name: customer-web-dist
          path: dist/customer

      - name: Upload deployment bundle
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: deploy/**
          target: /opt/minmin/
          overwrite: true
          debug: true
          strip_components: 1

      - name: Verify compose and nginx on server
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Listing /opt/minmin:"
            ls -la /opt/minmin
            echo "Listing /opt/minmin/nginx:"
            ls -la /opt/minmin/nginx
            echo "Listing /opt/minmin/nginx/conf.d:"
            ls -la /opt/minmin/nginx/conf.d

      - name: Verify nginx files on server
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Listing /opt/minmin/nginx and conf.d on server:"
            ls -la /opt/minmin/nginx || true
            ls -la /opt/minmin/nginx/conf.d || true

      - name: Start nginx and smoke test
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            # Ensure compose file exists
            test -f /opt/minmin/docker-compose.prod.yml || (echo "::error::Missing compose file at /opt/minmin/docker-compose.prod.yml" && exit 1)
            # Bring up supporting services for smoke tests
            echo "API_IMAGE=ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}:latest" | sudo tee /opt/minmin/deploy.env >/dev/null
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d nginx
            # Wait for Nginx to accept connections on :80
            for i in $(seq 1 20); do
              if curl -sI http://localhost >/dev/null; then
                echo "Nginx reachable on :80"
                break
              fi
              echo "Attempt $i: Nginx not yet reachable; sleeping 2s"
              sleep 2
              if [ "$i" = "20" ]; then
                echo '::error::Nginx not reachable on localhost after retries'
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml ps
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml logs nginx || true
                exit 1
              fi
            done

      - name: Issue Let's Encrypt certificates (webroot)
        if: ${{ vars.CERTBOT_EMAIL != '' }}
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            EMAIL='${{ vars.CERTBOT_EMAIL }}'
            if [ -z "$EMAIL" ]; then
              echo '::warning::CERTBOT_EMAIL repo variable is empty; skipping LE issuance'
              exit 0
            fi
            # Request/renew certs via webroot (served by nginx)
            sudo docker run --rm \
              -v /opt/minmin/letsencrypt:/etc/letsencrypt \
              -v /opt/minmin/acme:/var/www/certbot \
              certbot/certbot:latest certonly --webroot -w /var/www/certbot \
              -d stg.api.feed-intel.com -d stg.customer.feed-intel.com -d stg.restaurant.feed-intel.com \
              --agree-tos -m "$EMAIL" --no-eff-email --non-interactive --keep-until-expiring || true

            sync_copy() {
              dom="$1"; src="/opt/minmin/letsencrypt/live/$dom"; dst="/opt/minmin/tls/$dom";
              if [ -d "$src" ]; then
                sudo install -m 0644 -D "$src/fullchain.pem" "$dst/fullchain.pem"
                sudo install -m 0600 -D "$src/privkey.pem" "$dst/privkey.pem"
                echo "Installed certs for $dom"
              else
                echo "::warning::No LE cert directory for $dom; using existing certs if any"
              fi
            }
            sync_copy stg.api.feed-intel.com
            sync_copy stg.customer.feed-intel.com
            sync_copy stg.restaurant.feed-intel.com

            # Reload nginx to pick up new certs (ignore failures)
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml exec -T nginx nginx -s reload || true

      - name: Copy static sites to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: |
            dist/restaurant/**
          target: /opt/minmin/restaurant

      - name: Copy static sites to server (customer)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: |
            dist/customer/**
          target: /opt/minmin/customer

      - name: Verify and normalize static site roots
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            echo "Restaurant root contents:"; ls -la /opt/minmin/restaurant || true
            echo "Customer root contents:"; ls -la /opt/minmin/customer || true
            # Normalize customer web export into /opt/minmin/customer/client deterministically
            root="/opt/minmin/customer"; client="$root/client"; mkdir -p "$client"
            if [ ! -f "$client/index.html" ]; then
              if [ -d "$root/dist/client" ]; then
                echo "customer: Promoting dist/client -> client"
                sudo rsync -a "$root/dist/client/" "$client/" || true
                sudo rm -rf "$root/dist"
              elif [ -d "$root/dist/customer" ]; then
                echo "customer: Promoting dist/customer -> client"
                sudo rsync -a "$root/dist/customer/" "$client/" || true
                sudo rm -rf "$root/dist"
              else
                CAND=$(sudo find "$root" -maxdepth 3 -type f -name index.html | head -n 1 || true)
                if [ -n "$CAND" ]; then
                  SRC=$(dirname "$CAND")
                  echo "customer: Found index.html at $CAND; syncing $SRC -> client"
                  sudo rsync -a "$SRC/" "$client/" || true
                else
                  echo "::warning::customer: No client export found (looked for dist/* or index.html)"
                fi
              fi
            else
              echo "customer: client/index.html already present"
            fi
            # Ensure safe read perms for nginx
            sudo find /opt/minmin/restaurant -type d -exec chmod 755 {} +
            sudo find /opt/minmin/restaurant -type f -exec chmod 644 {} +
            sudo find /opt/minmin/customer -type d -exec chmod 755 {} +
            sudo find /opt/minmin/customer -type f -exec chmod 644 {} +
            echo "Restaurant (unchanged root):"; ls -la /opt/minmin/restaurant | head -n 40 || true
            echo "Post-normalize Customer:"; ls -la /opt/minmin/customer | head -n 40; ls -la /opt/minmin/customer/client | head -n 40 || true
            # Reload nginx to ensure it serves updated static
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml exec -T nginx nginx -s reload || \
              sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml restart nginx

      - name: Remote setup & deploy
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            sudo mkdir -p /opt/minmin/{customer,restaurant,media}
            sudo chown -R $USER:$USER /opt/minmin

            # Install Docker if missing
            if ! command -v docker >/dev/null 2>&1; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
            fi
            if ! docker compose version >/dev/null 2>&1; then
              echo "Installing docker compose plugin..."
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi

            # Login to GHCR for private image pulls
            echo ${{ secrets.GHCR_TOKEN }} | sudo docker login ghcr.io -u ${{ secrets.GHCR_USERNAME }} --password-stdin

            # Compose deploy env (for variable substitution like API_IMAGE)
            echo "API_IMAGE=ghcr.io/${{ steps.owner.outputs.lc }}/${{ env.API_IMAGE_NAME }}:latest" | sudo tee /opt/minmin/deploy.env >/dev/null

            # API application env
            sudo bash -c "echo 'DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}' > /opt/minmin/api.env"
            sudo bash -c "echo 'DJANGO_SETTINGS_MODULE=minminbe.settings' >> /opt/minmin/api.env"
            sudo bash -c "echo 'DEBUG=false' >> /opt/minmin/api.env"
            sudo bash -c "echo 'ALLOWED_HOSTS=${{ vars.API_DOMAIN }},${{ vars.CUSTOMER_DOMAIN }},${{ vars.RESTAURANT_DOMAIN }},localhost,127.0.0.1' >> /opt/minmin/api.env"
            sudo bash -c "echo 'CSRF_TRUSTED_ORIGINS=https://${{ vars.API_DOMAIN }},https://${{ vars.CUSTOMER_DOMAIN }},https://${{ vars.RESTAURANT_DOMAIN }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'DJANGO_ALLOWED_CORS_ORIGINS=https://${{ vars.CUSTOMER_DOMAIN }},https://${{ vars.RESTAURANT_DOMAIN }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'DATABASE_URL=${{ secrets.DATABASE_URL }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'REDIS_URL=${{ secrets.REDIS_URL }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'EMAIL_HOST=${{ vars.EMAIL_HOST || 'smtp.gmail.com' }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'EMAIL_HOST_USER=${{ secrets.EMAIL_HOST_USER || '' }}' >> /opt/minmin/api.env"
            sudo bash -c "echo 'EMAIL_HOST_PASSWORD=${{ secrets.EMAIL_HOST_PASSWORD || '' }}' >> /opt/minmin/api.env"

            # Inject domain names into nginx vhosts
            if [ -f /opt/minmin/nginx/conf.d/api.conf ]; then
              sed -i "s/api.local/${{ vars.API_DOMAIN }}/g" /opt/minmin/nginx/conf.d/api.conf
            else
              echo "::error::Missing /opt/minmin/nginx/conf.d/api.conf on server"; ls -la /opt/minmin/nginx/conf.d || true; exit 1
            fi
            if [ -f /opt/minmin/nginx/conf.d/customer.conf ]; then
              sed -i "s/customer.local/${{ vars.CUSTOMER_DOMAIN }}/g" /opt/minmin/nginx/conf.d/customer.conf
            else
              echo "::error::Missing /opt/minmin/nginx/conf.d/customer.conf on server"; exit 1
            fi
            if [ -f /opt/minmin/nginx/conf.d/restaurant.conf ]; then
              sed -i "s/restaurant.local/${{ vars.RESTAURANT_DOMAIN }}/g" /opt/minmin/nginx/conf.d/restaurant.conf
            else
              echo "::error::Missing /opt/minmin/nginx/conf.d/restaurant.conf on server"; exit 1
            fi

            # Reload nginx to pick up updated vhosts
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml restart nginx || \
              sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d nginx
            sleep 2

            # Sanity check compose file present
            test -f /opt/minmin/docker-compose.prod.yml || (echo "::error::Missing compose file at /opt/minmin/docker-compose.prod.yml" && exit 1)

            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml pull || true
            # Remove any orphaned/renamed services (like historical customer_server/customer_expo)
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d --remove-orphans
            # Ensure customer_expo (dev-only) is not running even if it exists from prior versions
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml rm -f customer_expo || true

            # Health check with retries (API behind Nginx)
            echo "Waiting for API to become healthy..."
            for i in $(seq 1 20); do
              if curl -fsS -H "Host: ${{ vars.API_DOMAIN }}" -o /dev/null http://localhost/healthz/; then
                echo "API healthy on attempt $i"
                break
              fi
              echo "Attempt $i: API not ready yet; sleeping 3s"
              sleep 3
              if [ "$i" = "20" ]; then
                echo 'API health check failed after retries'
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml ps
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml logs api || true
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml logs nginx || true
                exit 1
              fi
            done

      - name: Finalize stack and verify healthz
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            # Ensure compose file exists
            test -f /opt/minmin/docker-compose.prod.yml
            # Make sure all services are up
            sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml up -d
            # Health check with retries (header only)
            for i in $(seq 1 10); do
              status=$(curl -s -H "Host: ${{ vars.API_DOMAIN }}" -o /dev/null -w "%{http_code}" http://localhost/healthz/ || true)
              echo "healthz status: $status (attempt $i)"
              if [ "$status" = "200" ]; then
                echo "Final health check OK"
                break
              fi
              sleep 3
              if [ "$i" = "10" ]; then
                echo '::error::/healthz did not return 200 after retries'
                sudo docker compose --env-file /opt/minmin/deploy.env -f /opt/minmin/docker-compose.prod.yml ps
                exit 1
              fi
            done

      - name: Customer SSR smoke test
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            # Verify customer static site responds via Nginx
            for i in $(seq 1 10); do
              code=$(curl -s -o /dev/null -w "%{http_code}" -H "Host: ${{ vars.CUSTOMER_DOMAIN }}" http://localhost/index.html || true)
              echo "customer /index.html status: $code (attempt $i)"
              if [ "$code" = "200" ] || [ "$code" = "302" ] || [ "$code" = "301" ]; then
                echo "Customer static reachable"
                exit 0
              fi
              sleep 3
            done
            echo "::warning::Customer static did not return 2xx/3xx; verify /opt/minmin/customer/client contents and nginx customer vhost"
