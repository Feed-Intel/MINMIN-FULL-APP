from rest_framework import serializers
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework.exceptions import AuthenticationFailed
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from django.contrib.auth.hashers import make_password
from django.contrib.gis.geos import Point
from restaurant.branch.models import Branch
from .models import User
from .utils import get_user_branch, get_user_tenant
from datetime import timedelta
from django.utils.timezone import now
from minminbe.settings import EMAIL_HOST_USER
from rest_framework import serializers
from django.utils.translation import gettext_lazy as _
from rest_framework_simplejwt.tokens import RefreshToken

import random
import string
from django.contrib.auth.hashers import make_password
from django.core.exceptions import ValidationError
from django.contrib.auth.password_validation import validate_password

class UserSerializer(serializers.ModelSerializer):
    branch = serializers.PrimaryKeyRelatedField(queryset=Branch.objects.all(),required=False,allow_null=True)
    image = serializers.ImageField(required=False, allow_null=True)
    lat = serializers.FloatField(write_only=True, required=False)
    lng = serializers.FloatField(write_only=True, required=False)
    class Meta:
        model = User
        fields = ['id', 'full_name', 'phone', 'email', 'birthday', 'user_type', 'image' ,'branch', 'password','push_token','lat','lng']
        extra_kwargs = {
            'password': {'write_only': True}  # Ensures password is write-only
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.instance:
            self.fields['password'].required = False

    def get_branch(self, obj):
        return {
            'id': obj.branch.id,
            'address': obj.branch.address,
        }

    def to_representation(self, instance):
        representation = super().to_representation(instance)
        if instance.user_type == 'branch' or instance.user_type == 'restaurant':
            representation['branch'] = self.get_branch(instance)
        return representation

    def validate_password(self, value):
        """
        Ensure the password meets validation requirements.
        """
        try:
            validate_password(value)  # Use Django's built-in password validation
        except ValidationError as e:
            raise serializers.ValidationError(e.messages)
        return value

    def create(self, validated_data):
        """
        Create a new user instance with autogenerated password for branch user_type.
        """
        existing_user_branch = User.objects.filter(branch=validated_data.get('branch')).first()
        existing_user_email = User.objects.filter(email=validated_data.get('email')).first()
        existing_user_phone = User.objects.filter(phone=validated_data.get('phone')).first()
        if validated_data.get('user_type') == 'branch':
            if not validated_data.get('branch'):
                raise serializers.ValidationError({"error": "Branch is required."})
            elif existing_user_email:
                raise serializers.ValidationError({"error": "User with this email already exists."})
            elif existing_user_phone:
                raise serializers.ValidationError({"error": "User with this phone number already exists."})
            elif existing_user_branch:
                raise serializers.ValidationError({"error": "This branch is already assigned to another user."})
        
        # Autogenerate password for branch user_type
        if validated_data.get('user_type') == 'branch':
            password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            validated_data['password'] = make_password(password)


        email = validated_data.pop('email')
        user = User.objects.create_user(
            email=email.lower(),
            is_staff=False,
            is_superuser=False,
            **validated_data
        )
        if user.user_type == 'branch':
            from django.core.mail import send_mail
            send_mail(
                subject='Account Created',
                message=f'Your account has been created. Your Login Credentials are: Email: {email}, Password: {password}.',
                from_email=EMAIL_HOST_USER,
                recipient_list=[email],
                fail_silently=False,
            )
        return user

    def update(self, instance, validated_data):
        """
        Update user profile details but prevent email updates.
        """
        # Ensure email is not updated
        # if 'email' in validated_data:
        #     raise serializers.ValidationError({"email": "This field cannot be updated."})

        # Update editable fields
        instance.full_name = validated_data.get('full_name', instance.full_name)
        password = validated_data.get('password')
        if password:
            instance.password = make_password(password)
        instance.phone = validated_data.get('phone', instance.phone)
        instance.push_token = validated_data.get('push_token', instance.push_token)
        instance.birthday = validated_data.get('birthday', instance.birthday)
        if instance.user_type == 'branch':
            instance.branch = validated_data.get('branch', instance.branch)
        if 'image' in validated_data:
            instance.image = validated_data['image']

        # Save the updated instance
        instance.save()
        return instance


# from datetime import timedelta
# from rest_framework_simplejwt.tokens import RefreshToken

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    MAX_FAILED_ATTEMPTS = 5
    LOCK_TIME = timedelta(minutes=15)

    def get_token(self, user):
        token = super().get_token(user)
        token['id'] = str(user.id)
        token['email'] = user.email
        token['full_name'] = user.full_name
        token['user_type'] = user.user_type
        if user.user_type != 'customer':
            tenant = get_user_tenant(user)
            branch = get_user_branch(user)

            token['tenant'] = str(tenant.id) if tenant else None
            token['branch'] = str(branch.id) if branch else None
        return token

    def validate(self, attrs):
        email = attrs.get("email").lower()
        password = attrs.get("password")
        remember_me = self.context['request'].data.get("remember_me", "false")

        user = User.objects.filter(email=email).first()

        if user:
            if user.locked_until and user.locked_until > now():
                remaining_time = (user.locked_until - now()).seconds // 60
                raise AuthenticationFailed(f"Account locked. Try again in {remaining_time} minutes.")

            if not user.check_password(password):
                user.failed_attempts += 1
                user.save()
                if user.failed_attempts >= self.MAX_FAILED_ATTEMPTS:
                    user.locked_until = now() + self.LOCK_TIME
                    user.save()
                    raise AuthenticationFailed("Account locked due to multiple failed attempts. Try again later.")
                raise AuthenticationFailed("Invalid email or password")

            user.failed_attempts = 0
            user.locked_until = None
            user.save()

        if not user or not user.is_active:
            raise AuthenticationFailed("Invalid email or password or account inactive.")
        if user.otp:
            raise AuthenticationFailed("Account not verified. Please verify your OTP.")

        data = super().validate(attrs)

        # Generate tokens manually to set custom expiration
        refresh = self.get_token(self.user)

        if remember_me == "true":
            refresh.set_exp(lifetime=timedelta(days=30))  # 30 days for remember me
        else:
            refresh.set_exp(lifetime=timedelta(days=1))

        data["access"] = str(refresh.access_token)
        data["refresh"] = str(refresh)

        return data



class CustomRefreshToken(RefreshToken):
    @classmethod
    def for_user(cls, user):
        token = super().for_user(user)  # Generate the standard token

        # Add custom claims
        token['id'] = str(user.id)
        token['email'] = user.email
        token['full_name'] = user.full_name
        token['user_type'] = user.user_type

        if user.user_type != 'customer':
            if user.user_type == 'branch':
                token['branch'] = str(user.branch.id)
                token['tenant'] = str(user.branch.tenant.id)
            else:
                token['tenant'] = str(user.tenants.id)

        return token
